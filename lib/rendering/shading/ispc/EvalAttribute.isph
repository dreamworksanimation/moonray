// Copyright 2023 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

/// @file EvalAttribute.isph
///
/// <b>Shader writers should avoid directly using the evaluation functions defined
/// in this file.  They should instead use the attribute specific functions
/// defined in the shader's autogenerated attributes.isph file.<b>

#pragma once

#include <moonray/rendering/bvh/shading/ispc/State.isph>
#include <moonray/rendering/bvh/shading/ispc/ThreadLocalObjectState.isph>
#include <moonray/rendering/mcrt_common/Util.isph>
#include <scene_rdl2/common/platform/Platform.isph>
#include <scene_rdl2/common/math/ispc/asA.isph>
#include <scene_rdl2/common/math/ispc/autodiff.isph>
#include <scene_rdl2/common/math/ispc/Col3.isph>
#include <scene_rdl2/common/math/ispc/Color.isph>
#include <scene_rdl2/common/math/ispc/Mat4.isph>
#include <scene_rdl2/common/math/ispc/ReferenceFrame.isph>
#include <scene_rdl2/common/math/ispc/Vec2.isph>
#include <scene_rdl2/common/math/ispc/Vec3.isph>
#include <scene_rdl2/scene/rdl2/rdl2.isph>
#include <scene_rdl2/scene/rdl2/ISPCSupport.h>

struct Displacement;
struct Map;
struct NormalMap;
struct Material;
struct SceneObject;

/// Normal map LOD roughness compensation types
enum NormalAAStrategyType {
    NORMAL_AA_STRATEGY_NONE = 0,
    NORMAL_AA_STRATEGY_TOKSVIG = 1
};

// There is a bug in the optimization pass with ISPC 1.9.2 which causes certain
// generated code to crash in opt builds. The workaround is to move the offending
// code out into a separate file and build it in debug.
varying bool  derefAndCastToVaryingBool( const uniform uint8_t *varying ptr);
varying int   derefAndCastToVaryingInt(  const uniform uint8_t *varying ptr);
varying float derefAndCastToVaryingFloat(const uniform uint8_t *varying ptr);
varying Color derefAndCastToVaryingColor(const uniform uint8_t *varying ptr);
varying Vec2f derefAndCastToVaryingVec2f(const uniform uint8_t *varying ptr);
varying Vec3f derefAndCastToVaryingVec3f(const uniform uint8_t *varying ptr);
varying Mat4f derefAndCastToVaryingMat4f(const uniform uint8_t *varying ptr);

/// map sample function pointer.  matches rdl2::SampleFuncv
typedef void (* uniform SamplePtr)(const uniform Map *            uniform map,
                                         uniform ShadingTLState * uniform tls,
                                   const varying State *          uniform state,
                                         varying Color *          uniform color);

/// normal map sample function pointer.  matches rdl2::SampleNormalFuncv
typedef void (* uniform SampleNormalPtr)(const uniform NormalMap * uniform normalMap,
                                               uniform ShadingTLState * uniform tls,
                                         const varying State *          uniform state,
                                               varying Vec3f *          uniform normal);

/// @{
/// @brief get an RDL bool attribute
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform bool
getBool(const uniform SceneObject * uniform sceneObject,
        const uniform BoolAttrKey * uniform key)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    return get(ctx.attributes, key);
}
inline uniform bool
getBool(const uniform Material    * uniform sceneObject,
        const uniform BoolAttrKey * uniform key)
{
    return getBool((const SceneObject * uniform) sceneObject, key);
}
inline uniform bool
getBool(const uniform Map         * uniform sceneObject,
        const uniform BoolAttrKey * uniform key)
{
    return getBool((const SceneObject * uniform) sceneObject, key);
}
inline uniform bool
getBool(const uniform NormalMap   * uniform sceneObject,
        const uniform BoolAttrKey * uniform key)
{
    return getBool((const SceneObject * uniform) sceneObject, key);
}
inline uniform bool
getBool(const uniform Displacement * uniform sceneObject,
        const uniform BoolAttrKey  * uniform key)
{
    return getBool((const SceneObject * uniform) sceneObject, key);
}
/// @}
        
/// {
/// @brief get an RDL Int attribute
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform int
getInt(const uniform SceneObject * uniform sceneObject,
       const uniform IntAttrKey  * uniform key)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    return get(ctx.attributes, key);
}
inline uniform int
getInt(const uniform Material   * uniform sceneObject,
       const uniform IntAttrKey * uniform key)
{
    return getInt((const SceneObject * uniform) sceneObject, key);
}
inline uniform int
getInt(const uniform Map        * uniform sceneObject,
       const uniform IntAttrKey * uniform key)
{
    return getInt((const SceneObject * uniform) sceneObject, key);
}
inline uniform int
getInt(const uniform NormalMap  * uniform sceneObject,
       const uniform IntAttrKey * uniform key)
{
    return getInt((const SceneObject * uniform) sceneObject, key);
}
inline uniform int
getInt(const uniform Displacement * uniform sceneObject,
       const uniform IntAttrKey   * uniform key)
{
    return getInt((const SceneObject * uniform) sceneObject, key);
}
/// @}

/// @{
/// @brief get an RDL float3 attribute as a Color
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform Color
getColor(const uniform SceneObject   * uniform sceneObject,
         const uniform Float3AttrKey * uniform keyIn)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    AttributeKey * uniform key = (AttributeKey * uniform) keyIn;
    uniform float * uniform ans =
        (uniform float * uniform)(ctx.attributes + key->mOffset);

    uniform Color result = Color_ctor(ans);
    return result;
}
inline uniform Color
getColor(const uniform Material      * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getColor((const SceneObject * uniform) sceneObject, key);
}
inline uniform Color
getColor(const uniform Map           * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getColor((const SceneObject * uniform) sceneObject, key);
}
inline uniform Color
getColor(const uniform NormalMap     * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getColor((const SceneObject * uniform) sceneObject, key);
}
inline uniform Color
getColor(const uniform Displacement  * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getColor((const SceneObject * uniform) sceneObject, key);
}
/// @}

/// @{
/// @brief get an RDL float attribute
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform float
getFloat(const uniform SceneObject  * uniform sceneObject,
         const uniform FloatAttrKey * uniform key)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    return get(ctx.attributes, key);
}
inline uniform float
getFloat(const uniform Material     * uniform sceneObject,
         const uniform FloatAttrKey * uniform key)
{
    return getFloat((const SceneObject * uniform) sceneObject, key);
}
inline uniform float
getFloat(const uniform Map          * uniform sceneObject,
         const uniform FloatAttrKey * uniform key)
{
    return getFloat((const SceneObject * uniform) sceneObject, key);
}
inline uniform float
getFloat(const uniform NormalMap    * uniform sceneObject,
         const uniform FloatAttrKey * uniform key)
{
    return getFloat((const SceneObject * uniform) sceneObject, key);
}
inline uniform float
getFloat(const uniform Displacement * uniform sceneObject,
         const uniform FloatAttrKey * uniform key)
{
    return getFloat((const SceneObject * uniform) sceneObject, key);
}
/// @}

/// @{
/// @brief get an RDL float2 attribute as a Vec2f
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform Vec2f
getVec2f(const uniform SceneObject   * uniform sceneObject,
         const uniform Float2AttrKey * uniform keyIn)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    AttributeKey * uniform key = (AttributeKey * uniform) keyIn;
    uniform float * uniform ans =
        (uniform float * uniform)(ctx.attributes + key->mOffset);

    uniform Vec2f result = Vec2f_ctor(ans[0], ans[1]);
    return result;
}
inline uniform Vec2f
getVec2f(const uniform Material      * uniform sceneObject,
         const uniform Float2AttrKey * uniform key)
{
    return getVec2f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec2f
getVec2f(const uniform Map           * uniform sceneObject,
         const uniform Float2AttrKey * uniform key)
{
    return getVec2f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec2f
getVec2f(const uniform NormalMap     * uniform sceneObject,
         const uniform Float2AttrKey * uniform key)
{
    return getVec2f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec2f
getVec2f(const uniform Displacement  * uniform sceneObject,
         const uniform Float2AttrKey * uniform key)
{
    return getVec2f((const SceneObject * uniform) sceneObject, key);
}
/// @}

/// @{
/// @brief get an RDL float3 attribute as a Vec3f
/// @note Use the attribute specific getAttrName() function instead if possible
inline uniform Vec3f
getVec3f(const uniform SceneObject   * uniform sceneObject,
         const uniform Float3AttrKey * uniform keyIn)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);
    AttributeKey * uniform key = (AttributeKey * uniform) keyIn;
    uniform float * uniform ans =
        (uniform float * uniform)(ctx.attributes + key->mOffset);

    uniform Vec3f result = Vec3f_ctor(ans[0], ans[1], ans[2]);
    return result;
}
inline uniform Vec3f
getVec3f(const uniform Material      * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getVec3f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec3f
getVec3f(const uniform Map           * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getVec3f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec3f
getVec3f(const uniform NormalMap     * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getVec3f((const SceneObject * uniform) sceneObject, key);
}
inline uniform Vec3f
getVec3f(const uniform Displacement  * uniform sceneObject,
         const uniform Float3AttrKey * uniform key)
{
    return getVec3f((const SceneObject * uniform) sceneObject, key);
}
/// @}

/// @brief evaluate a map binding
/// @return false if no map binding, true if binding exists and
/// was evaluated.  results returned in color.
inline uniform bool
evalMapBinding(const uniform SceneObject *    uniform sceneObject,
                     uniform ShadingTLState * uniform tls,
               const varying State &                  state,
               const uniform AttributeKey *   uniform key,
                     varying Color *          uniform color)
{
    uniform rdl2Ctx ctx = getRdl2Ctx((PTR8) sceneObject);

    // within the bindings, get the pointer to the thing sceneObject/key is
    // bound to.
    int64 * uniform ptrToMapObjPtr = (int64 * uniform) (ctx.bindings + key->mIndex);

    // deref to get the map object pointer
    int64 * uniform mapObjPtr = (int64 * uniform) *ptrToMapObjPtr;

    // if null, no binding
    if (mapObjPtr == NULL) return false;

    // we have a binding, find the sample function and evaluate it
    int64 * uniform ptr =
        (int64 * uniform) *(mapObjPtr + (MAP_SAMPLEFUNCV_OFFSET / 8));

    // if the function pointer is null, no binding
    if (ptr == NULL) return false;

    // all good, call the sample function.
    SamplePtr sampleFn = (SamplePtr) ptr;
    const uniform int64 start = getInclusiveTime(mapObjPtr, tls);
    sampleFn((const Map * uniform) mapObjPtr, tls, &state, color);
    const uniform int64 end = getInclusiveTime(mapObjPtr, tls);
    subtractTimeInChild(sceneObject, tls, start, end);
    return true;
}

inline uniform bool
evalMapBinding(const uniform Material *       uniform sceneObject,
                     uniform ShadingTLState * uniform tls,
               const varying State &                  state,
               const uniform AttributeKey *   uniform key,
                     varying Color *          uniform color)
{
    return evalMapBinding((const SceneObject * uniform) sceneObject, tls, state, key, color);
}

inline uniform bool
evalMapBinding(const uniform Map *            uniform sceneObject,
                     uniform ShadingTLState * uniform tls,
               const varying State &                  state,
               const uniform AttributeKey *   uniform key,
                     varying Color *          uniform color)
{
    return evalMapBinding((const SceneObject * uniform) sceneObject, tls, state, key, color);
}

inline uniform bool
evalMapBinding(const uniform NormalMap *      uniform sceneObject,
                     uniform ShadingTLState * uniform tls,
               const varying State &                  state,
               const uniform AttributeKey *   uniform key,
                     varying Color *          uniform color)
{
    return evalMapBinding((const SceneObject * uniform) sceneObject, tls, state, key, color);
}

inline uniform bool
evalMapBinding(const uniform Displacement *   uniform sceneObject,
                     uniform ShadingTLState * uniform tls,
               const varying State &                  state,
               const uniform AttributeKey *   uniform key,
                     varying Color *          uniform color)
{
    return evalMapBinding((const SceneObject * uniform) sceneObject, tls, state, key, color);
}

/// @{
/// @brief Evaluate a Color attribute
/// @note Use the attribute specific evalAttrName() function instead if possible
inline varying Color
evalColor(const uniform SceneObject *    uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    // first get the base attribute value
    const uniform Color base = getColor(sceneObject, keyIn);
    Color result = base;

    if (!isBlack(base)) {
        // now evaluate and apply a map binding
        Color binding;
        if (evalMapBinding(sceneObject, tls, state, (const AttributeKey * uniform) keyIn,
                           &binding)) {
            result = result * binding;
        }
    }

    return result;
}
inline Color
evalColor(const uniform Material *       uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)

{
    return evalColor((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Color
evalColor(const uniform Map *            uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)

{
    return evalColor((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Color
evalColor(const uniform NormalMap *      uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)

{
    return evalColor((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
/// @}

/// @{
/// @brief Evaluate a color component
/// @note Use the component specific evalCompName() function instead if possible
inline Color
evalColorComponent(const uniform SceneObject *    uniform sceneObject,
                         uniform ShadingTLState * uniform tls,
                   const varying State &                  state,
                   const uniform BoolAttrKey *    uniform showKeyIn,
                   const uniform FloatAttrKey *   uniform factorKeyIn,
                   const uniform Float3AttrKey *  uniform valueKeyIn)

{
    Color result = Color_ctor(0.f);

    if (getBool(sceneObject, showKeyIn)) {
        const uniform float factor = getFloat(sceneObject, factorKeyIn);
        if (!isZero(factor)) {
            result = evalColor(sceneObject, tls, state, valueKeyIn) * factor;
        }
    }

    return result;
}
inline Color
evalColorComponent(const uniform Material *       uniform sceneObject,
                         uniform ShadingTLState * uniform tls,
                   const varying State &                  state,
                   const uniform BoolAttrKey *    uniform showKeyIn,
                   const uniform FloatAttrKey *   uniform factorKeyIn,
                   const uniform Float3AttrKey *  uniform valueKeyIn)

{
    return evalColorComponent((const SceneObject * uniform) sceneObject, tls,
                              state, showKeyIn, factorKeyIn, valueKeyIn);
}
inline Color
evalColorComponent(const uniform Map *            uniform sceneObject,
                         uniform ShadingTLState * uniform tls,
                   const varying State &                  state,
                   const uniform BoolAttrKey *    uniform showKeyIn,
                   const uniform FloatAttrKey *   uniform factorKeyIn,
                   const uniform Float3AttrKey *  uniform valueKeyIn)

{
    return evalColorComponent((const SceneObject * uniform) sceneObject, tls,
                              state, showKeyIn, factorKeyIn, valueKeyIn);
}
inline Color
evalColorComponent(const uniform NormalMap *      uniform sceneObject,
                         uniform ShadingTLState * uniform tls,
                   const varying State &                  state,
                   const uniform BoolAttrKey *    uniform showKeyIn,
                   const uniform FloatAttrKey *   uniform factorKeyIn,
                   const uniform Float3AttrKey *  uniform valueKeyIn)

{
    return evalColorComponent((const SceneObject * uniform) sceneObject, tls,
                              state, showKeyIn, factorKeyIn, valueKeyIn);
}
/// @}

/// @{
/// @brief evaluate a float attribute (potentially bound to a map shader)
/// @note Use the attribute specific evalAttrName() function instead if possible
inline varying float
evalFloat(const uniform SceneObject * uniform  sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State                  &state,
          const uniform FloatAttrKey * uniform  keyIn)
{
    const uniform float base = getFloat(sceneObject, keyIn);
    float result = base;

    if (!isZero(base)) {
        Color binding;
        if (evalMapBinding(sceneObject, tls, state, (const AttributeKey * uniform) keyIn,
                           &binding)) {
            float avg = (binding.r + binding.g + binding.b) / 3.0f;
            result *= avg;
        }
    }

    return result;
}
inline float
evalFloat(const uniform Material *       uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform FloatAttrKey *   uniform keyIn)
{
    return evalFloat((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline float
evalFloat(const uniform Map *            uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform FloatAttrKey *   uniform keyIn)
{
    return evalFloat((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline float
evalFloat(const uniform NormalMap *      uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform FloatAttrKey *   uniform keyIn)
{
    return evalFloat((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline float
evalFloat(const uniform Displacement *   uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform FloatAttrKey *   uniform keyIn)
{
    return evalFloat((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
/// @}

inline void logNormalError(
    const uniform SceneObject * uniform  sceneObject,
    uniform ShadingTLState * uniform  tls)
{
    // log an error message
    // address of Shader::mInvalidNormalMapLogEvent
    const uniform int * uniform ptr = (const uniform int * uniform)
        (((const uniform int8 * uniform) sceneObject) +
         SHADER_INVALID_NORMAL_MAP_LOG_EVENT);
    logEvent(sceneObject, tls, *ptr);
}

inline Vec3f
evalNormalImpl(
    const uniform SceneObject * uniform  sceneObject,
    uniform ShadingTLState * uniform  tls,
    const varying State &state,
    const varying Vec3f& normalMapValue,
    const varying float normalDial,
    const uniform int normalMapSpace,
    varying bool& needsAdapting)
{
    const Vec3f& N = state.mN;

    // Check for numerical issues
    if (// Check for nan and infinity
        (isnan(normalMapValue.x) ||
         isnan(normalMapValue.y) ||
         isnan(normalMapValue.z)) ||
        (!isfinite(normalMapValue.x) ||
         !isfinite(normalMapValue.y) ||
         !isfinite(normalMapValue.z)) ||
        // We require a non-zero length vector
        isZero(normalMapValue)) {

        logNormalError(sceneObject, tls);
        needsAdapting = false;
        return N;
    }

    Vec3f result = normalMapValue;

    if (normalMapSpace == 0) { // TBN space
        // Re-center sampled normal from [0, 1] --> [-1, 1]
        // z is usually encoded from [0.5, 1.0] so that this re-centering
        // keeps it positive (in [0, 1])
        result = 2.0f * result - Vec3f_ctor(1.0f);

        // We check that the vector be in the upper half plane of tangent space.
        if (result.z < 0.f) {
            logNormalError(sceneObject, tls);
            needsAdapting = false;
            return N;
        }

        // Transform from tangent space to shade space
        ReferenceFrame frame;
        ReferenceFrame_init(frame, N, normalize(state.mdPds));
        result = localToGlobal(frame, result);
    }

    result = normalize(result);

    // Linearly interpolate between the surface normal and the mapped
    // normal if our blend factor is anything other than 1.
    if (normalDial != 1.0f) {
        result = normalize(state.mN + (result - state.mN) * saturate(normalDial));
    }

    needsAdapting = true;
    return result;
}

inline Vec3f
evalNormal(
    const uniform SceneObject * uniform  sceneObject,
    uniform ShadingTLState * uniform  tls,
    const varying State &state,
    const varying Vec3f& normalMapValue,
    const varying float normalDial,
    const uniform int normalMapSpace)
{
    varying bool needsAdapting;
    varying Vec3f result = evalNormalImpl(sceneObject, tls, state,
                                          normalMapValue, normalDial, normalMapSpace,
                                          needsAdapting);
    if (needsAdapting) {
        // hack the result if it is not physically plausible
        result = Intersection_adaptNormal((const varying Intersection &) state, result);
    }
    return result;
}

inline Vec3f
evalToonNormal(
    const uniform SceneObject * uniform  sceneObject,
    uniform ShadingTLState * uniform  tls,
    const varying State &state,
    const varying Vec3f& normalMapValue,
    const varying float normalDial,
    const uniform int normalMapSpace)
{
    // Intended for use only by diffuse lobes from NPR materials.
    varying bool needsAdapting;
    varying Vec3f result = evalNormalImpl(sceneObject, tls, state,
                                          normalMapValue, normalDial, normalMapSpace,
                                          needsAdapting);
    if (needsAdapting) {
        // hack the result if it is not physically plausible,
        // unless the material is requesting physically implausible normals.

        // Some NPR materials that want to allow for completely arbitrary shading normals
        // can request that the integrator does not perform any light culling based on the
        // normal. In those cases, adaptToonNormal() will check the flag set on the Intersection
        // and not adapt the normal. This allows the explicit input normals to be unbent
        // and the black artifacts that would otherwise occur are mitigated because
        // there is no light culling.
        result = Intersection_adaptToonNormal((const varying Intersection &) state, result);
    }
    return result;
}

/// @{
/// @brief Evaluate a vec3f attribute as a normal
/// @note Use the specific evalNormalName() function instead if possible
inline varying Vec3f
evalNormal(const uniform SceneObject      * uniform  sceneObject,
                 uniform ShadingTLState   * uniform  tls,
           const varying State                      &state,
           const uniform Float3AttrKey    * uniform  valueKey,
           const uniform FloatAttrKeyISPC * uniform  dialKey,
           const uniform IntAttrKey       * uniform  spaceKey)
{
    Vec3f N = state.mN;

    uniform float normalDial = getFloat(sceneObject, dialKey);
    if (isZero(normalDial)) {
        return N;
    }

    Color normalMapColor;
    if (!evalMapBinding(sceneObject, tls, state,
                        (const AttributeKey * uniform) valueKey,
                        &normalMapColor)) {
        return N;
    }

    Vec3f normalMapValue = Vec3f_ctor(normalMapColor.r,
                                      normalMapColor.g,
                                      normalMapColor.b);

    const uniform int normalMapSpace = getInt(sceneObject, spaceKey);
    return evalNormal(sceneObject, tls, state,
                      normalMapValue,
                      normalDial,
                      normalMapSpace);
}
inline Vec3f
evalNormal(const uniform Material      * uniform  sceneObject,
                 uniform ShadingTLState *uniform  tls,
           const varying State                   &state,
           const uniform Float3AttrKey * uniform  valueKey,
           const uniform FloatAttrKey  * uniform  dialKey,
           const uniform IntAttrKey * uniform  spaceKey)
{
    return evalNormal((const SceneObject * uniform) sceneObject, tls, state,
                      valueKey, dialKey, spaceKey);
}
inline Vec3f
evalNormal(const uniform Map           * uniform  sceneObject,
                 uniform ShadingTLState *uniform  tls,
           const varying State                   &state,
           const uniform Float3AttrKey * uniform  valueKey,
           const uniform FloatAttrKey  * uniform  dialKey,
           const uniform IntAttrKey * uniform  spaceKey)
{
    return evalNormal((const SceneObject * uniform) sceneObject, tls, state,
                      valueKey, dialKey, spaceKey);
}
inline Vec3f
evalNormal(const uniform Displacement  * uniform  sceneObject,
                 uniform ShadingTLState *uniform  tls,
           const varying State                   &state,
           const uniform Float3AttrKey * uniform  valueKey,
           const uniform FloatAttrKey  * uniform  dialKey,
           const uniform IntAttrKey * uniform  spaceKey)
{
    return evalNormal((const SceneObject * uniform) sceneObject, tls, state,
                      valueKey, dialKey, spaceKey);
}
/// @}

/// @{
/// @brief Evaluate a NormalMap attribute as a normal
/// @note Use the specific evalNormalName() function instead if possible
inline varying Vec3f
evalNormal(const uniform SceneObject      * uniform  sceneObject,
                 uniform ShadingTLState   * uniform  tls,
           const varying State                      &state,
           const uniform NormalMap        * uniform  normalMap,
           const uniform SampleNormalPtr             sampleNormalFn,
           const varying float normalDial,
                 varying float            * uniform  lengthN)
{
    if (!normalMap || !sampleNormalFn || isZero(normalDial)) {
        return state.mN;
    }

    Vec3f normalMapValue;
    sampleNormalFn(normalMap, tls, &state, &normalMapValue);

    // Calculating the normal's length here is necessary for the Toksvig
    // normal AA strategy used in the Dwa materials since it must then
    // be normalized to render properly.
    if (lengthN != NULL) {
        *lengthN = length(normalMapValue);
    }

    return evalNormal(sceneObject,
                      tls,
                      state,
                      normalMapValue,
                      normalDial,
                      1); // render space
}

inline varying Vec3f
evalNormal(const uniform Material      * uniform  sceneObject,
                 uniform ShadingTLState   * uniform  tls,
           const varying State                      &state,
           const uniform NormalMap        * uniform  normalMap,
           const uniform SampleNormalPtr             sampleNormalFn,
           const varying float normalDial,
                 varying float            * uniform  lengthN)
{
    return evalNormal((const SceneObject * uniform) sceneObject,
                      tls,
                      state,
                      normalMap,
                      sampleNormalFn,
                      normalDial,
                      lengthN);
}
inline varying Vec3f
evalNormal(const uniform Material      * uniform  sceneObject,
                 uniform ShadingTLState   * uniform  tls,
           const varying State                      &state,
           const uniform NormalMap        * uniform  normalMap,
           const uniform SampleNormalPtr             sampleNormalFn,
           const varying float normalDial)
{
    return evalNormal((const SceneObject * uniform) sceneObject,
                      tls,
                      state,
                      normalMap,
                      sampleNormalFn,
                      normalDial,
                      NULL);
}
inline varying Vec3f
evalNormal(const uniform Map              * uniform  sceneObject,
                 uniform ShadingTLState   * uniform  tls,
           const varying State                      &state,
           const uniform NormalMap        * uniform  normalMap,
           const uniform SampleNormalPtr             sampleNormalFn,
           const varying float normalDial)
{
    return evalNormal((const SceneObject * uniform) sceneObject,
                      tls,
                      state,
                      normalMap,
                      sampleNormalFn,
                      normalDial,
                      NULL);
}
/// @}

/// @{
/// @brief Evaluate a NormalMap attribute as a toon normal
/// @note Use the specific evalNormalName() function instead if possible
inline varying Vec3f
evalToonNormal(const uniform SceneObject      * uniform  sceneObject,
                     uniform ShadingTLState   * uniform  tls,
               const varying State                      &state,
               const uniform NormalMap        * uniform  normalMap,
               const uniform SampleNormalPtr             sampleNormalFn,
               const varying float normalDial,
                     varying float            * uniform  lengthN)
{
    if (!normalMap || !sampleNormalFn || isZero(normalDial)) {
        return state.mN;
    }

    Vec3f normalMapValue;
    sampleNormalFn(normalMap, tls, &state, &normalMapValue);

    // Calculating the normal's length here is necessary for the Toksvig
    // normal AA strategy used in the Dwa materials since it must then
    // be normalized to render properly.
    if (lengthN != NULL) {
        *lengthN = length(normalMapValue);
    }

    return evalToonNormal(sceneObject,
                          tls,
                          state,
                          normalMapValue,
                          normalDial,
                          1); // render space
}

inline varying Vec3f
evalToonNormal(const uniform Material      * uniform  sceneObject,
                     uniform ShadingTLState   * uniform  tls,
               const varying State                      &state,
               const uniform NormalMap        * uniform  normalMap,
               const uniform SampleNormalPtr             sampleNormalFn,
               const varying float normalDial,
                     varying float            * uniform  lengthN)
{
    return evalToonNormal((const SceneObject * uniform) sceneObject,
                          tls,
                          state,
                          normalMap,
                          sampleNormalFn,
                          normalDial,
                          lengthN);
}
/// @}

/// @{
/// @brief evaluate a Vec3f attribute that is potentially bound to a map
/// @note Use the attribute specifc evalAttrName() function instead if possible
/// @note unlike evalColor, if the attribute is bound to map, the map
/// evaluation is returned _not_ the product of the attribute and the
/// map evaluation.
inline varying Vec3f
evalVec3f(const uniform SceneObject *    uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    Vec3f result;
    Color binding;
    if (evalMapBinding(sceneObject, tls, state, (const AttributeKey * uniform) keyIn,
                        &binding)) {
        result = asAVec3f(binding);
    } else {
        result = getVec3f(sceneObject, keyIn);
    }
    return result;
}
inline Vec3f
evalVec3f(const uniform Material *       uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    return evalVec3f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Vec3f
evalVec3f(const uniform Map *            uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    return evalVec3f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Vec3f
evalVec3f(const uniform NormalMap *      uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    return evalVec3f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Vec3f
evalVec3f(const uniform Displacement *   uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float3AttrKey *  uniform keyIn)
{
    return evalVec3f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
/// @}

/// @{
/// @brief Evaluate a Vec2f attribute
/// @note Use the attribute specific evalAttrName() function instead if possible
inline varying Vec2f
evalVec2f(const uniform SceneObject *    uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float2AttrKey *  uniform keyIn)
{
    // first get the base attribute value
    const uniform Vec2f base = getVec2f(sceneObject, keyIn);
    Vec2f result = base;

    if (!isZero(base)) {
        // now evaluate and apply a map binding
        Color binding;
        if (evalMapBinding(sceneObject, tls, state, (const AttributeKey * uniform) keyIn,
                           &binding)) {
            result.x = result.x * binding.r;
            result.y = result.y * binding.g;
        }
    }

    return result;
}
inline Vec2f
evalVec2f(const uniform Material *       uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float2AttrKey *  uniform keyIn)

{
    return evalVec2f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Vec2f
evalVec2f(const uniform Map *            uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float2AttrKey *  uniform keyIn)

{
    return evalVec2f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
inline Vec2f
evalVec2f(const uniform NormalMap *      uniform sceneObject,
                uniform ShadingTLState * uniform tls,
          const varying State &                  state,
          const uniform Float2AttrKey *  uniform keyIn)

{
    return evalVec2f((const SceneObject * uniform) sceneObject, tls, state, keyIn);
}
/// @}

/// @{
/// @brief get a geom::Primitive bool attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying bool
getBoolAttribute(      uniform ShadingTLState * uniform tls,
                 const varying State &                  state,
                 const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingBool(base + tls->mAttributeOffsets[key]);
}

inline varying bool
getBoolAttribute(      uniform ShadingTLState * uniform tls,
                 const varying State &                  state,
                 const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingBool(base + tls->mAttributeOffsets[key]);
}
/// @}

/// @{
/// @brief get a geom::Primitive int attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying int
getIntAttribute(      uniform ShadingTLState * uniform tls,
                const varying State &                  state,
                const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingInt(base + tls->mAttributeOffsets[key]);
}

inline varying int
getIntAttribute(      uniform ShadingTLState * uniform tls,
                const varying State &                  state,
                const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingInt(base + tls->mAttributeOffsets[key]);
}

/// @}

/// @{
/// @brief get a geom::Primitive float attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying float
getFloatAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingFloat(base + tls->mAttributeOffsets[key]);
}

inline varying float
getFloatAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingFloat(base + tls->mAttributeOffsets[key]);
}
/// @}

/// @{
/// @brief get a geom::Primitive float attribute derivatives with regards to
///     s in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying float
getdFloatAttributeds(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdsProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingFloat(
            base + tls->mAttributeOffsets[key] + sizeof(uniform float));
    } else {
        return 0.0f;
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive float attribute derivatives with regards to
///     t in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying float
getdFloatAttributedt(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdtProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingFloat(
            base + tls->mAttributeOffsets[key] + 2.0f * sizeof(uniform float));
    } else {
        return 0.0f;
    }
}
/// @}

/// @{
/// @brief get a geom::Primitive float attribute derivatives with regards to
///     x in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying float
getdFloatAttributedx(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdFloatAttributeds(tls, state, key) * getdSdx(state) +
           getdFloatAttributedt(tls, state, key) * getdTdx(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive float attribute derivatives with regards to
///     y in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying float
getdFloatAttributedy(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdFloatAttributeds(tls, state, key) * getdSdy(state) +
           getdFloatAttributedt(tls, state, key) * getdTdy(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Color attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Color
getColorAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingColor(base + tls->mAttributeOffsets[key]);
}

inline varying Color
getColorAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingColor(base + tls->mAttributeOffsets[key]);
}

/// @}

/// @{
/// @brief get a geom::Primitive Color attribute derivatives with regards to
///     s in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Color
getdColorAttributeds(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdsProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingColor(
            base + tls->mAttributeOffsets[key] + sizeof(uniform Color));
    } else {
        return Color_ctor(0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Color attribute derivatives with regards to
///     t in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Color
getdColorAttributedt(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdtProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingColor(
            base + tls->mAttributeOffsets[key] + 2.0f * sizeof(uniform Color));
    } else {
        return Color_ctor(0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Color attribute derivatives with regards to
///     x in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Color
getdColorAttributedx(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdColorAttributeds(tls, state, key) * getdSdx(state) +
           getdColorAttributedt(tls, state, key) * getdTdx(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Color attribute derivatives with regards to
///     y in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Color
getdColorAttributedy(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdColorAttributeds(tls, state, key) * getdSdy(state) +
           getdColorAttributedt(tls, state, key) * getdTdy(state);
}
/// @}


/// @{
/// @brief get a geom::Primitive Vec2f attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec2f
getVec2fAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingVec2f(base + tls->mAttributeOffsets[key]);
}

inline varying Vec2f
getVec2fAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingVec2f(base + tls->mAttributeOffsets[key]);
}

/// @}

/// @{
/// @brief get a geom::Primitive Vec2f attribute derivatives with regards to
///     s in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec2f
getdVec2fAttributeds(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdsProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingVec2f(
            base + tls->mAttributeOffsets[key] + sizeof(uniform Vec2f));
    } else {
        return Vec2f_ctor(0.0f, 0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Vec2f attribute derivatives with regards to
///     t in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec2f
getdVec2fAttributedt(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdtProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingVec2f(
            base + tls->mAttributeOffsets[key] + 2.0f * sizeof(uniform Vec2f));
    } else {
        return Vec2f_ctor(0.0f, 0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Vec2f attribute derivatives with regards to
///     x in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec2f
getdVec2fAttributedx(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdVec2fAttributeds(tls, state, key) * getdSdx(state) +
           getdVec2fAttributedt(tls, state, key) * getdTdx(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Vec2f attribute derivatives with regards to
///     y in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec2f
getdVec2fAttributedy(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdVec2fAttributeds(tls, state, key) * getdSdy(state) +
           getdVec2fAttributedt(tls, state, key) * getdTdy(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Vec3f attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec3f
getVec3fAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingVec3f(base + tls->mAttributeOffsets[key]);
}

inline varying Vec3f
getVec3fAttribute(uniform ShadingTLState * uniform tls,
                  const varying State &state,
                  const varying int key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingVec3f(base + tls->mAttributeOffsets[key]);
}
/// @}

/// @{
/// @brief get a geom::Primitive Vec3f attribute derivatives with regards to
///     s in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec3f
getdVec3fAttributeds(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdsProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingVec3f(
            base + tls->mAttributeOffsets[key] + sizeof(uniform Vec3f));
    } else {
        return Vec3f_ctor(0.0f, 0.0f, 0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Vec3f attribute derivatives with regards to
///     t in surface st
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec3f
getdVec3fAttributedt(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    if (isdtProvided(state, key)) {
        MNRY_ASSERT(tls->mAttributeOffsets);
        const uniform uint8_t *varying base =
            (const uniform uint8_t *varying)Address64_get(state.mData);
        return derefAndCastToVaryingVec3f(
            base + tls->mAttributeOffsets[key] + 2.0f * sizeof(uniform Vec3f));
    } else {
        return Vec3f_ctor(0.0f, 0.0f, 0.0f);
    }
}

/// @}

/// @{
/// @brief get a geom::Primitive Vec3f attribute derivatives with regards to
///     x in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec3f
getdVec3fAttributedx(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdVec3fAttributeds(tls, state, key) * getdSdx(state) +
           getdVec3fAttributedt(tls, state, key) * getdTdx(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Vec3f attribute derivatives with regards to
///     y in pixel space xy
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Vec3f
getdVec3fAttributedy(   uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    return getdVec3fAttributeds(tls, state, key) * getdSdy(state) +
           getdVec3fAttributedt(tls, state, key) * getdTdy(state);
}
/// @}

/// @{
/// @brief get a geom::Primitive Mat4f attribute
/// @param tls
/// @param state
/// @param key The global attribute key index.
inline varying Mat4f
getMat4fAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const uniform int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingMat4f(base + tls->mAttributeOffsets[key]);
}

inline varying Mat4f
getMat4fAttribute(      uniform ShadingTLState * uniform tls,
                  const varying State &                  state,
                  const varying int                      key)
{
    MNRY_ASSERT(tls->mAttributeOffsets);
    const uniform uint8_t *varying base = (const uniform uint8_t *varying)Address64_get(state.mData);
    return derefAndCastToVaryingMat4f(base + tls->mAttributeOffsets[key]);
}

/// @}

